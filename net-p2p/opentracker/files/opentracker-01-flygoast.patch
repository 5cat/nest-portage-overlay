diff --git a/Makefile b/Makefile
index ed280be..65729a9 100644
--- a/Makefile
+++ b/Makefile
@@ -24,13 +26,14 @@ BINDIR?=$(PREFIX)/bin
 #FEATURES+=-DWANT_ACCESSLIST_BLACK
 #FEATURES+=-DWANT_ACCESSLIST_WHITE
 
-#FEATURES+=-DWANT_SYNC_LIVE
+#FEATURES+=-DWANT_SYNC_LIVE
+#FEATURES+=-DSYNC_LIVE_UNICAST
 #FEATURES+=-DWANT_IP_FROM_QUERY_STRING
 #FEATURES+=-DWANT_COMPRESSION_GZIP
 #FEATURES+=-DWANT_COMPRESSION_GZIP_ALWAYS
 #FEATURES+=-DWANT_LOG_NETWORKS
 #FEATURES+=-DWANT_RESTRICT_STATS
-#FEATURES+=-DWANT_IP_FROM_PROXY
+#FEATURES+=-DWANT_IP_FROM_PROXY
 #FEATURES+=-DWANT_FULLLOG_NETWORKS
 #FEATURES+=-DWANT_LOG_NUMWANT
 #FEATURES+=-DWANT_MODEST_FULLSCRAPES
@@ -38,6 +41,7 @@ BINDIR?=$(PREFIX)/bin
 #FEATURES+=-DWANT_SYSLOGS
 #FEATURES+=-DWANT_DEV_RANDOM
 FEATURES+=-DWANT_FULLSCRAPE
+#FEATURES+=-DWANT_PERSISTENCE
 
 #FEATURES+=-D_DEBUG_HTTPERROR
 
@@ -48,8 +52,8 @@ CFLAGS+=-I$(LIBOWFAT_HEADERS) -Wall -pipe -Wextra #-ansi -pedantic
 LDFLAGS+=-L$(LIBOWFAT_LIBRARY) -lowfat -pthread -lpthread -lz
 
 BINARY =opentracker
-HEADERS=trackerlogic.h scan_urlencoded_query.h ot_mutex.h ot_stats.h ot_vector.h ot_clean.h ot_udp.h ot_iovec.h ot_fullscrape.h ot_accesslist.h ot_http.h ot_livesync.h ot_rijndael.h
-SOURCES=opentracker.c trackerlogic.c scan_urlencoded_query.c ot_mutex.c ot_stats.c ot_vector.c ot_clean.c ot_udp.c ot_iovec.c ot_fullscrape.c ot_accesslist.c ot_http.c ot_livesync.c ot_rijndael.c
+HEADERS=trackerlogic.h scan_urlencoded_query.h ot_mutex.h ot_stats.h ot_vector.h ot_clean.h ot_udp.h ot_iovec.h ot_fullscrape.h ot_accesslist.h ot_http.h ot_livesync.h ot_rijndael.h ot_persist.h
+SOURCES=opentracker.c trackerlogic.c scan_urlencoded_query.c ot_mutex.c ot_stats.c ot_vector.c ot_clean.c ot_udp.c ot_iovec.c ot_fullscrape.c ot_accesslist.c ot_http.c ot_livesync.c ot_rijndael.c ot_persist.c
 SOURCES_proxy=proxy.c ot_vector.c ot_mutex.c
 
 OBJECTS = $(SOURCES:%.c=%.o)
diff --git a/ODB_FORMAT.md b/ODB_FORMAT.md
new file mode 100644
index 0000000..02731b8
--- /dev/null
+++ b/ODB_FORMAT.md
@@ -0,0 +1,47 @@
+OPENTRACKER ODB File Format
+===========================
+
+`opentracker` *.odb file is a binary representation of the in-memory store. 
+This binary file is sufficient to completely restore `opentracker` state.
+
+High Level Algorithm to parse ODB
+=================================
+
+At a high level, the ODB file has the following structure
+<pre><code>
+----------------------------------- # ODB is a binary format. There are no new lines or spaces in the file.
+4f 50 45 4e 54 52 41 43 4b 45 52    # Magic String "OPENTRACKER"
+30 30 30 33                         # ODB Version Number in ASCII characters. In this case, version = "0001" = 1 
+-----------------------------------
+FE                                  # FE = Opcode that indicates following is a torrent information.
+----------------------------------- # Torrent information starts from here.
+00 02 2e 33 01 c4 a1 df bb 82 
+1f 51 0f b5 b6 02 6f 93 6e 9f       # 20 byte info_hash of torrent
+----------------------------------- 
+e2 37 59 01 00 00 00 00             # Last access time in minutes since UNIX epoch, 8 bytes.
+                                    # At present, when loading ODB file, just use current clock, ignore this.
+-----------------------------------
+00 00 00 00 00 00 00 00             # Seeding peer count for current torrent. 8 bytes long integer in little endian. 
+                                    # NOT used at present.
+-----------------------------------
+00 00 00 00 00 00 00 00             # Total peer count for current torrent. 8 bytes long integer in little endian.
+                                    # NOT used at present.
+-----------------------------------
+00 00 00 00 00 00 00 00             # Download times of files in current torrent. 8 bytes long integer in little endian.
+                                    # NOT used at present.
+-----------------------------------
+01 00 00 00                         # Peer count in current peer, 4 bytes integer in little endian.
+----------------------------------- # Peers information starts from here.
+7f 00 00 01                         # 4 bytes ip address in network byte order. In this case, 0x7f000001 = "127.0.0.1"
+1b 31                               # 2 bytes port in network byte order. In this case, 0x1b31 = 6961.
+80                                  # Flag of peers. SEEDING = 0x80, COMPLETED = 0x40, STOPPED = 0x20, LEECHING = 0x00
+00                                  # Reserved. Just set zero.
+-----------------------------------
+...                                 # Other peers information.
+-----------------------------------
+FE                                 
+----------------------------------- 
+...                                 # Other torrent information.
+-----------------------------------
+FF                                  # EOF opcode.
+</code></pre>
diff --git a/opentracker.c b/opentracker.c
index e122bab..6a8d675 100644
--- a/opentracker.c
+++ b/opentracker.c
@@ -36,6 +36,7 @@
 #include "ot_accesslist.h"
 #include "ot_stats.h"
 #include "ot_livesync.h"
+#include "ot_persist.h"
 
 /* Globals */
 time_t       g_now_seconds;
@@ -112,7 +113,7 @@ static void usage( char *name ) {
   "\n", name );
 }
 
-#define HELPLINE(opt,desc) fprintf(stderr, "\t%-10s%s\n",opt,desc)
+#define HELPLINE(opt,desc) fprintf(stderr, "\t%-15s%s\n",opt,desc)
 static void help( char *name ) {
   usage( name );
 
@@ -373,6 +374,21 @@ static int scan_ip6_port( const char *src, ot_ip6 ip, uint16 *port ) {
   return off+s-src;
 }
 
+static int scan_save_params( const char *src, int *seconds, int *changes) {
+  const char *s = src;
+  int off = 0;
+  while( isspace(*s) ) ++s;
+
+  if( !(off = scan_int( s, seconds ) ) )
+    return 0;
+  s += off;
+  while( isspace(*s) ) ++s;
+  if( !(off = scan_int( s, changes ) ) )
+    return 0;
+  s += off;
+  return off+s-src;
+}
+
 int parse_configfile( char * config_filename ) {
   FILE *  accesslist_filehandle;
   char    inbuf[512];
@@ -448,13 +464,35 @@ int parse_configfile( char * config_filename ) {
       set_config_option( &g_redirecturl, p+21 );
 #ifdef WANT_SYNC_LIVE
     } else if(!byte_diff(p, 24, "livesync.cluster.node_ip" ) && isspace(p[24])) {
+#ifdef SYNC_LIVE_UNICAST
+      uint16_t tmpport = LIVESYNC_PORT;
+      if( !scan_ip6_port( p+25, tmpip, &tmpport )) goto parse_error;
+      livesync_add_node( tmpip, tmpport);
+      accesslist_blessip( tmpip, OT_PERMISSION_MAY_LIVESYNC );
+#else 
       if( !scan_ip6( p+25, tmpip )) goto parse_error;
       accesslist_blessip( tmpip, OT_PERMISSION_MAY_LIVESYNC );
+#endif /* SYNC_LIVE_UNICAST */
     } else if(!byte_diff(p, 23, "livesync.cluster.listen" ) && isspace(p[23])) {
       uint16_t tmpport = LIVESYNC_PORT;
       if( !scan_ip6_port( p+24, tmpip, &tmpport )) goto parse_error;
+#ifdef SYNC_LIVE_UNICAST
+      livesync_bind_ucast( tmpip, tmpport );
+#else
       livesync_bind_mcast( tmpip, tmpport );
+#endif /* SYNC_LIVE_UNICAST */
 #endif
+#ifdef WANT_PERSISTENCE
+    } else if (!byte_diff(p, 12, "persist.mode" ) && isspace(p[12])) {
+      if (persist_set_mode(p+13) < 0)  goto parse_error;
+    } else if (!byte_diff(p, 12, "persist.file" ) && isspace(p[12])) {
+      set_config_option( &g_persistfile, p+13 );
+    } else if (!byte_diff(p, 12, "persist.save" ) && isspace(p[12])) {
+      int seconds, changes;
+      if( !scan_save_params( p+13, &seconds, &changes )) goto parse_error;
+      if (seconds < 1 || changes < 0) goto parse_error;
+      persist_append_save_param(seconds, changes);
+#endif /* WANT_PERSISTENCE */
     } else
       fprintf( stderr, "Unhandled line in config file: %s\n", inbuf );
     continue;
@@ -594,7 +632,11 @@ int main( int argc, char **argv ) {
 #ifdef WANT_SYNC_LIVE
       case 's':
         if( !scan_ushort( optarg, &tmpport)) { usage( argv[0] ); exit( 1 ); }
+#ifdef SYNC_LIVE_UNICAST
+        livesync_bind_ucast( serverip, tmpport); break;
+#else
         livesync_bind_mcast( serverip, tmpport); break;
+#endif /* SYNC_LIVE_UNICAST */
 #endif
       case 'd': set_config_option( &g_serverdir, optarg ); break;
       case 'u': set_config_option( &g_serveruser, optarg ); break;
@@ -649,6 +691,11 @@ int main( int argc, char **argv ) {
   /* Init all sub systems. This call may fail with an exit() */
   trackerlogic_init( );
 
+#ifdef WANT_PERSISTENCE
+  if( g_persistfile )
+    persist_load_file( );
+#endif /* WANT_PERSISTENCE */
+
   if( statefile )
     load_state( statefile );
 
diff --git a/opentracker.conf.sample b/opentracker.conf.sample
index db45122..e567209 100644
--- a/opentracker.conf.sample
+++ b/opentracker.conf.sample
@@ -55,6 +55,11 @@
 #      appear anywhere on your tracker.
 #
 # access.stats_path stats
+#
+# access.proxy 127.0.0.1
+#
+#      If you want ip from a proxy, set your proxy ip address here.
+
 
 # III) Live sync uses udp multicast packets to keep a cluster of opentrackers
 #      synchronized. This option tells opentracker which port to listen for
@@ -104,3 +109,31 @@
 #      redirect to another location (shell option -r).
 #
 # tracker.redirect_url https://your.tracker.local/
+
+# VII) Persistence of memory data, save the torrents and peers information 
+#      on disk.
+#
+#      Spicify the persistence mode. 
+#          "null" for turning persistence off. 
+#          "dump" for dumping the memory data structure.
+#
+# persist.mode      dump
+#
+#      Tell opentracker which persist file to used. When startup, opentracker
+#      will load data from this file.
+#
+# persist.file      /path/to/persist.odb
+#
+#      Will save the memory data if both the given number of seconds and the 
+#      given number of change operations occurred.
+#
+# persist.save      <seconds> <changes>
+#
+#      In the example below the behaviour will be to save:
+#      after 900 sec (15 min) if at least 1 change operations occurred
+#      after 300 sec (5 min) if at least 10 change operations occurred
+#      after 60 sec if at least 10000 change operations occurred
+#
+# persist.save      900 1
+# persist.save      300 10
+# persist.save      60 10000
diff --git a/ot_accesslist.c b/ot_accesslist.c
index 9757c73..2fa0ef5 100644
--- a/ot_accesslist.c
+++ b/ot_accesslist.c
@@ -293,8 +293,9 @@ int accesslist_blessip( ot_ip6 ip, ot_permissions permissions ) {
     if( permissions & OT_PERMISSION_MAY_LIVESYNC   ) off += snprintf( _debug+off, 512-off, " may_sync_live" );
     if( permissions & OT_PERMISSION_MAY_FULLSCRAPE ) off += snprintf( _debug+off, 512-off, " may_fetch_fullscrapes" );
     if( permissions & OT_PERMISSION_MAY_PROXY      ) off += snprintf( _debug+off, 512-off, " may_proxy" );
-    if( !permissions ) off += snprintf( _debug+off, sizeof(_debug)-off, " nothing\n" );
+    if( !permissions ) off += snprintf( _debug+off, sizeof(_debug)-off, " nothing" );
     _debug[off++] = '.';
+    _debug[off++] = '\n';
     write( 2, _debug, off );
   }
 #endif
diff --git a/ot_http.c b/ot_http.c
index 70575c8..9d77725 100644
--- a/ot_http.c
+++ b/ot_http.c
@@ -401,11 +401,11 @@ static ssize_t http_handle_announce( const int64 sock, struct ot_workstruct *ws,
       OT_SETIP( &ws->peer, cookie->ip );
   } else
 #endif
+  OT_SETIP( &ws->peer, cookie->ip );
 
   ws->peer_id = NULL;
   ws->hash = NULL;
 
-  OT_SETIP( &ws->peer, cookie->ip );
   OT_SETPORT( &ws->peer, &port );
   OT_PEERFLAG( &ws->peer ) = 0;
   numwant = 50;
diff --git a/ot_livesync.c b/ot_livesync.c
index 5c4f224..34f9513 100644
--- a/ot_livesync.c
+++ b/ot_livesync.c
@@ -26,7 +26,13 @@
 
 #ifdef WANT_SYNC_LIVE
 
+#ifdef SYNC_LIVE_UNICAST
+static ot_ip6         g_nodeip[OT_ADMINIP_MAX];
+static uint16_t       g_nodeport[OT_ADMINIP_MAX];
+static unsigned int   g_node_count = 0;
+#else
 char groupip_1[4] = { 224,0,23,5 };
+#endif /* SYNC_LIVE_UNICAST */
 
 #define LIVESYNC_INCOMING_BUFFSIZE          (256*256)
 
@@ -40,11 +46,17 @@ enum { OT_SYNC_PEER };
 /* Forward declaration */
 static void * livesync_worker( void * args );
 
+#ifdef SYNC_LIVE_UNICAST
+/* For outgoing and incoming packets */
+static int64    g_socket = -1;
+
+#else
 /* For outgoing packets */
 static int64    g_socket_in = -1;
 
 /* For incoming packets */
 static int64    g_socket_out = -1;
+#endif /* SYNC_LIVE_UNICAST */
 
 char            g_outbuf[LIVESYNC_OUTGOING_BUFFSIZE_PEERS];
 static size_t   g_outbuf_data;
@@ -53,7 +65,11 @@ static ot_time  g_next_packet_time;
 static pthread_t thread_id;
 void livesync_init( ) {
   
+#ifdef SYNC_LIVE_UNICAST
+  if( g_socket == -1 ) 
+#else
   if( g_socket_in == -1 )
+#endif /* SYNC_LIVE_UNICAST */
     exerr( "No socket address for live sync specified." );
 
   /* Prepare outgoing peers buffer */
@@ -67,14 +83,51 @@ void livesync_init( ) {
 }
 
 void livesync_deinit() {
+#ifdef SYNC_LIVE_UNICAST
+  if( g_socket != -1 )
+    close( g_socket );
+#else
   if( g_socket_in != -1 )
     close( g_socket_in );
   if( g_socket_out != -1 )
     close( g_socket_out );
+#endif /* SYNC_LIVE_UNICAST */
 
   pthread_cancel( thread_id );
 }
 
+#ifdef SYNC_LIVE_UNICAST
+
+int livesync_add_node( ot_ip6 ip, uint16_t port ) {
+  if( g_node_count >= OT_ADMINIP_MAX )
+    return -1;
+
+  memcpy(g_nodeip + g_node_count, ip, sizeof(ot_ip6));
+  g_nodeport[g_node_count++] = port;
+  return 0;
+}
+
+/* Create unicast socket for listening and create sending socket */
+void livesync_bind_ucast( char *ip, uint16_t port ) {
+  char *v4ip;
+
+  if( !ip6_isv4mapped(ip))
+    exerr("v6 ucast support not yet available.");
+  v4ip = ip+12;
+
+  if( g_socket != -1 )
+    exerr("Error: Livesync listen ip specified twice.");
+
+  if( ( g_socket = socket_udp4( )) < 0)
+    exerr("Error: Cant create live sync socket." );
+  ndelay_off(g_socket);
+
+  if( socket_bind4_reuse( g_socket, v4ip, port ) == -1 )
+    exerr("Error: Cant bind live sync socket." );
+}
+
+#else
+
 void livesync_bind_mcast( ot_ip6 ip, uint16_t port) {
   char tmpip[4] = {0,0,0,0};
   char *v4ip;
@@ -105,8 +158,17 @@ void livesync_bind_mcast( ot_ip6 ip, uint16_t port) {
   socket_mcloop4(g_socket_out, 0);
 }
 
+#endif /* SYNC_LIVE_UNICAST */
+
 static void livesync_issue_peersync( ) {
+#ifdef SYNC_LIVE_UNICAST
+  unsigned int i;
+  for( i=0; i<g_node_count; ++i )
+    socket_send4(g_socket, g_outbuf, g_outbuf_data, (char *)g_nodeip[i] + 12, g_nodeport[i]);
+#else
   socket_send4(g_socket_out, g_outbuf, g_outbuf_data, groupip_1, LIVESYNC_PORT);
+#endif /* SYNC_LIVE_UNICAST */
+
   g_outbuf_data = sizeof( g_tracker_id ) + sizeof( uint32_t );
   g_next_packet_time = g_now_seconds + LIVESYNC_MAXDELAY;
 }
@@ -170,7 +232,11 @@ static void * livesync_worker( void * args ) {
   memcpy( in_ip, V4mappedprefix, sizeof( V4mappedprefix ) );
 
   while( 1 ) {
+#ifdef SYNC_LIVE_UNICAST
+    ws.request_size = socket_recv4(g_socket, (char*)ws.inbuf, LIVESYNC_INCOMING_BUFFSIZE, 12+(char*)in_ip, &in_port);
+#else
     ws.request_size = socket_recv4(g_socket_in, (char*)ws.inbuf, LIVESYNC_INCOMING_BUFFSIZE, 12+(char*)in_ip, &in_port);
+#endif /* SYNC_LIVE_UNICAST */
 
     /* Expect at least tracker id and packet type */
     if( ws.request_size <= (ssize_t)(sizeof( g_tracker_id ) + sizeof( uint32_t )) )
diff --git a/ot_livesync.h b/ot_livesync.h
index 1a3ed45..bf58388 100644
--- a/ot_livesync.h
+++ b/ot_livesync.h
@@ -44,8 +44,16 @@
 void livesync_init();
 void livesync_deinit();
 
+#ifdef SYNC_LIVE_UNICAST
+
+int livesync_add_node( ot_ip6 ip, uint16_t port );
+
+/* Create unicast socket for listening and create sending socket */
+void livesync_bind_ucast( char *ip, uint16_t port );
+#else
 /* Join multicast group for listening and create sending socket */
 void livesync_bind_mcast( char *ip, uint16_t port );
+#endif /* SYNC_LIVE_UNICAST */
 
 /* Inform live sync about whats going on. */
 void livesync_tell( struct ot_workstruct *ws );
diff --git a/ot_persist.c b/ot_persist.c
new file mode 100644
index 0000000..1a6180e
--- /dev/null
+++ b/ot_persist.c
@@ -0,0 +1,514 @@
+/* This file add persistence of peers and torrents in memory on the fly.
+ * Author: FengGu <flygoast@126.com>
+ *
+ * This software was written by Dirk Engling <erdgeist@erdgeist.org>
+ It is considered beerware. Prost. Skol. Cheers or whatever.
+
+ $id$ */
+
+/* System */
+#include <stdlib.h>
+#include <errno.h>
+#include <arpa/inet.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/mman.h>
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <assert.h>
+#ifdef WANT_SYSLOGS
+#include <syslog.h>
+#endif
+
+/* Libowfat */
+#include "byte.h"
+#include "io.h"
+#include "ip4.h"
+#include "ip6.h"
+
+/* Opentracker */
+#include "trackerlogic.h"
+#include "ot_mutex.h"
+#include "ot_accesslist.h"
+#include "ot_persist.h"
+
+#ifdef _DEBUG
+#define _DEBUG_PERSIST
+#endif /* _DEBUG */
+
+#ifdef _DEBUG_PERSIST
+#define LOG_ERR( ... ) fprintf( stderr, __VA_ARGS__ )
+#else
+#define LOG_ERR( ... )
+#endif /* _DEBUG_PERSIST */
+
+#define PERSIST_SLEEP_INTERVAL      1000000     /* macroseconds */
+
+/* Just for file corruption checking  */
+#define OT_DUMP_TORRENT     0xfe
+#define OT_DUMP_EOF         0xff
+
+#define OT_DUMP_IDENTI              "OPENTRACKER"
+#define OT_DUMP_IDENTI_LEN          (sizeof(OT_DUMP_IDENTI) - 1)
+#define OT_DUMP_VERSION             "0001"
+#define OT_DUMP_VERSION_LEN         (sizeof(OT_DUMP_VERSION) - 1)
+#define OT_DUMP_IDENTI_VERSION      (OT_DUMP_IDENTI OT_DUMP_VERSION)
+#define OT_DUMP_IDENTI_VERSION_LEN  (sizeof(OT_DUMP_IDENTI_VERSION) - 1)
+
+typedef struct dump_saveparam {
+    time_t  seconds;
+    int     changes;
+} dump_saveparam_t;
+
+char *  g_persistfile;
+int     g_persistmode = PMODE_NULL;
+static int     dump_dirty;
+static int     dump_lastsave;
+static size_t  saveparam_len;
+static dump_saveparam_t *saveparams;
+
+static int persist_add_peer(ot_hash *hash, ot_peerlist *peer_list, ot_peer *peer) {
+  int         exactmatch, delta_torrentcount = 0;
+  ot_torrent *torrent;
+  ot_peer    *peer_dest;
+
+  /* eliminate compiler warnings */
+  (void)peer_list;
+
+  ot_vector  *torrents_list = mutex_bucket_lock_by_hash(*hash);
+
+  if( !accesslist_hashisvalid( hash ) ) {
+    mutex_bucket_unlock_by_hash( *hash, 0 );
+    return 0;
+  }
+
+  torrent = vector_find_or_insert( torrents_list, (void*)hash, sizeof( ot_torrent ), OT_HASH_COMPARE_SIZE, &exactmatch );
+  if( !torrent ) {
+    mutex_bucket_unlock_by_hash( *hash, 0 );
+    return 0;
+  }
+
+  if( !exactmatch ) {
+    /* Create a new torrent entry, then */
+    memcpy( torrent->hash, hash, sizeof(ot_hash) );
+
+    if( !( torrent->peer_list = malloc( sizeof (ot_peerlist) ) ) ) {
+      vector_remove_torrent( torrents_list, torrent );
+      mutex_bucket_unlock_by_hash( *hash, 0 );
+      return 0;
+    }
+
+    byte_zero( torrent->peer_list, sizeof( ot_peerlist ) );
+    delta_torrentcount = 1;
+  }
+
+  /* Ignore torrent base in odb file, just use current clock. */
+  torrent->peer_list->base = g_now_minutes;
+
+  /* Check for peer in torrent */
+  peer_dest = vector_find_or_insert_peer( &(torrent->peer_list->peers), peer, &exactmatch );
+  if( !peer_dest ) {
+    mutex_bucket_unlock_by_hash( *hash, delta_torrentcount );
+    return 0;
+  }
+
+  /* If we hadn't had a match, create peer there */
+  if( !exactmatch ) {
+    torrent->peer_list->peer_count++;
+    if( OT_PEERFLAG(peer) & PEER_FLAG_COMPLETED )
+      torrent->peer_list->down_count++;
+    if( OT_PEERFLAG(peer) & PEER_FLAG_SEEDING )
+      torrent->peer_list->seed_count++;
+  } else {
+    LOG_ERR("Repeat peer in a same torrent\n");
+    assert(0);
+  }
+
+  memcpy( peer_dest, peer, sizeof(ot_peer) );
+
+  mutex_bucket_unlock_by_hash( *hash, delta_torrentcount );
+  return 0;
+}
+
+static int persist_load_peers(FILE *fp, ot_hash *hash, ot_peerlist *peer_list) {
+  unsigned int count;
+  unsigned int i;
+  ot_peer  peer;
+#ifdef _DEBUG_PERSIST
+  struct in_addr myaddr;
+  char str[40];
+#endif /* _DEBUG_PERSIST */
+
+  if (fread(&count, sizeof(unsigned int), 1, fp) == 0) goto rerr;
+  LOG_ERR("Peer count: %d\n", count);
+  if (count == 0) return 0;
+
+  for (i = 0; i < count; ++i) {
+    if (fread(&peer, sizeof(ot_peer), 1, fp) != 1) goto rerr;
+#ifdef _DEBUG_PERSIST
+    /* ot_peer's ip and port is big endian. */
+    myaddr.s_addr = *(unsigned int *)&peer; 
+    if (!inet_ntop(AF_INET, &myaddr, str, sizeof(str))) {
+      LOG_ERR("inet_ntop failed");
+      assert(0);
+    }
+    LOG_ERR("%s:%d\n", str, ntohs(*(unsigned short *)((uint8_t*)(&peer) + (OT_IP_SIZE))));
+#endif /* _DEBUG_PERSIST */
+    if (persist_add_peer(hash, peer_list, &peer) < 0) {
+      LOG_ERR("persist_add_peer failed\n");
+      return -1;
+    }
+  }
+  return 0;
+
+rerr:
+  LOG_ERR("%s\n", strerror(errno));
+  return -1;
+}
+
+#ifdef _DEBUG_PERSIST
+static int urlencode(const char *src, int len, char *ret, int size) {
+  int i;
+  int j = 0;
+  char c;
+
+  assert(src && ret && len && size);
+
+  for (i = 0; i < len && j < size; i++) {
+    c = src[i];
+    if ((c >= 'A') && (c <= 'Z')) {
+      ret[j++] = c;
+    } else if ((c >='a') && (c <= 'z')) {
+      ret[j++] = c;
+    } else if ((c >='0') && (c <= '9')) {
+      ret[j++] = c;
+    } else if (c == ' ') {
+      ret[j++] = '+';
+    } else {
+      if (j + 3 < size) {
+        sprintf(ret + j, "%%%02X", (unsigned char)c);
+        j += 3;
+      } else {
+        return 0;
+      }
+    }
+  }
+
+  ret[j] = '\0';
+
+  return j;
+}
+#endif /* _DEBUG_PERSIST */
+
+static int persist_load_torrent(FILE *fp) {
+  ot_hash       hash;
+  ot_peerlist   peer_list;
+#ifdef _DEBUG_PERSIST
+  char          log_buf[512];
+#endif /* _DEBUG_PERSIST */
+
+  /* load torrent hash */
+  if (fread(&hash, sizeof(ot_hash), 1, fp) != 1) goto rerr;
+
+#ifdef _DEBUG_PERSIST
+  if (urlencode((const char *)&hash, sizeof(ot_hash), log_buf, 512) <= 0) {
+    LOG_ERR("urlencode failed\n");
+    assert(0);
+  }
+  LOG_ERR("%s\n", log_buf);
+#endif /* _DEBUG_PERSIST */
+
+  /*
+   * load peer_list data:
+   *
+   * struct ot_peerlist {
+   *   ot_time        base;
+   *   size_t         seed_count;
+   *   size_t         peer_count;
+   *   size_t         down_count;
+   *   ot_vector      peers;
+   * }
+   *
+   */
+  if (fread(&peer_list.base, sizeof(ot_time), 1, fp) != 1) goto rerr;
+  if (fread(&peer_list.seed_count, sizeof(size_t), 1, fp) != 1) goto rerr;
+  if (fread(&peer_list.peer_count, sizeof(size_t), 1, fp) != 1) goto rerr;
+  if (fread(&peer_list.down_count, sizeof(size_t), 1, fp) != 1) goto rerr;
+  if (persist_load_peers(fp, &hash, &peer_list) < 0) goto rerr;
+
+  return 0;
+
+rerr:
+  LOG_ERR("%s\n", strerror(errno));
+  return -1;
+}
+
+int persist_load_file() {
+  FILE     *fp;
+  uint8_t   buf[1024];
+  int       version;
+#ifdef _DEBUG_PERSIST
+  int       torrent_cnt = 0;
+#endif /* _DEBUG_PERSIST */
+
+  if (!g_persistfile) {
+    g_persistfile = strdup("opentracker.odb");
+  }
+
+  fp = fopen(g_persistfile, "r");
+  if (!fp) {
+    LOG_ERR("%s\n", strerror(errno));
+    return 0;
+  }
+
+  if (fread(buf, OT_DUMP_IDENTI_VERSION_LEN, 1, fp) == 0) {
+    LOG_ERR("%s\n", strerror(errno));
+    goto rerr;
+  }
+
+  if (memcmp(buf, OT_DUMP_IDENTI, OT_DUMP_IDENTI_LEN) != 0) {
+    LOG_ERR("%s\n", strerror(errno));
+    goto rerr;
+  }
+
+  version = atoi((const char *)buf + OT_DUMP_IDENTI_LEN);
+  if (version != 1) {
+    LOG_ERR("Can't handle ODB format version %d\n", version);
+    goto rerr;
+  }
+
+  for ( ; ; ) {
+    if (fread(buf, 1, 1, fp) == 0) goto rerr;
+    if (buf[0] != OT_DUMP_TORRENT && buf[0] != OT_DUMP_EOF) {
+      LOG_ERR("ODB file corrupted\n");
+      goto rerr;
+    }
+
+    if (buf[0] == OT_DUMP_EOF) {
+      break;
+    }
+    if (persist_load_torrent(fp) < 0) goto rerr;
+#ifdef _DEBUG_PERSIST
+    ++torrent_cnt;
+#endif /* _DEBUG_PERSIST */
+  }
+
+#ifdef _DEBUG_PERSIST
+  LOG_ERR("Load ODB file success: torrent count: %d\n", torrent_cnt);
+#endif /* _DEBUG_PERSIST */
+  fclose(fp);
+  return 0;
+
+rerr:
+  fclose(fp);
+  return -1;
+}
+
+void persist_change(struct ot_workstruct *ws) {
+  (void)ws; /* In "dump" mode, don't use this param */
+  switch (g_persistmode) {
+  case PMODE_NULL:
+    return;
+  case PMODE_DUMP:
+    ++dump_dirty;
+    break;
+  default:
+    assert(0);
+    break;
+  }
+  return;
+}
+
+void persist_append_save_param(time_t seconds, int changes) {
+  saveparams = realloc(saveparams, sizeof(dump_saveparam_t) * (saveparam_len + 1));
+  if (!saveparams) {
+    LOG_ERR("out of memory\n");
+    exit(123);
+  }
+
+  saveparams[saveparam_len].seconds = seconds;
+  saveparams[saveparam_len].changes = changes;
+  ++saveparam_len;
+}
+
+static int persist_dump_peers(ot_peerlist *peer_list, FILE *fp ) {
+  unsigned int bucket, num_buckets = 1;
+  ot_vector    *bucket_list = &peer_list->peers;
+  unsigned int count = 0;
+
+  if( OT_PEERLIST_HASBUCKETS(peer_list) ) {
+    num_buckets = bucket_list->size;
+    bucket_list = (ot_vector *)bucket_list->data;
+  }
+
+  /* write peers count */
+  for (bucket = 0; bucket < num_buckets; ++bucket) {
+    count += bucket_list[bucket].size;
+  }
+  if (fwrite(&count, sizeof(unsigned int), 1, fp) == 0) goto werr;
+
+  for (bucket = 0; bucket < num_buckets; ++bucket) {
+    ot_peer *peers = (ot_peer*)bucket_list[bucket].data;
+    size_t  peer_count = bucket_list[bucket].size;
+
+    while( peer_count-- ) {
+      if (fwrite(peers++, sizeof(ot_peer), 1, fp) == 0) goto werr;
+    }
+  }
+  return 0;
+
+werr:
+  LOG_ERR("%s: persist dump peers failed\n", __FUNCTION__);
+  return -1;
+}
+
+static int persist_dump_torrent(ot_torrent* torrent, FILE *fp ) {
+  uint8_t c;
+  ot_peerlist *peer_list = torrent->peer_list;
+  ot_hash     *hash = &torrent->hash;
+
+  /* Write TORRENT opcode */
+  c = OT_DUMP_TORRENT;
+  if (fwrite(&c, 1, 1, fp) != 1) goto werr;
+
+  /* Write torrent hash */
+  if (fwrite(hash, sizeof(ot_hash), 1, fp) == 0) goto werr;
+
+  /*
+   * write peer_list data:
+   *
+   * struct ot_peerlist {
+   *   ot_time        base;
+   *   size_t         seed_count;
+   *   size_t         peer_count;
+   *   size_t         down_count;
+   *   ot_vector      peers;
+   * }
+   *
+   */
+  if (fwrite(&peer_list->base, sizeof(ot_time), 1, fp) == 0) goto werr;
+  if (fwrite(&peer_list->seed_count, sizeof(size_t), 1, fp) == 0) goto werr;
+  if (fwrite(&peer_list->peer_count, sizeof(size_t), 1, fp) == 0) goto werr;
+  if (fwrite(&peer_list->down_count, sizeof(size_t), 1, fp) == 0) goto werr;
+  if (persist_dump_peers(peer_list, fp) < 0) goto werr;
+
+  return 0;
+
+werr:
+  LOG_ERR("%s: persist dump torrent failed\n", __FUNCTION__);
+  return -1;
+}
+
+static int persist_dump_make() {
+  int bucket;
+  size_t j;
+  uint8_t c;
+  FILE *fp;
+  char tmpfile[256];
+
+  snprintf(tmpfile, 256, "temp-%u.odb", (unsigned int)g_now_seconds);
+
+  LOG_ERR("Start write odb file:%s\n", tmpfile);
+
+  fp = fopen(tmpfile, "w");
+  if (!fp) return -1;
+
+  /* write identifier and version */
+  if (fwrite(OT_DUMP_IDENTI_VERSION, OT_DUMP_IDENTI_VERSION_LEN, 1, fp) == 0) goto werr;
+
+  /* Dump torrents and peers */
+  for(bucket=0; bucket < OT_BUCKET_COUNT; ++bucket ) {
+    ot_vector  *torrents_list = mutex_bucket_lock( bucket );
+    ot_torrent *torrents = (ot_torrent*)(torrents_list->data);
+
+    for( j=0; j < torrents_list->size; ++j )
+      if( persist_dump_torrent( torrents + j, fp ) < 0 ) {
+        mutex_bucket_unlock( bucket, 0 );
+        goto werr;
+      }
+
+    mutex_bucket_unlock( bucket, 0 );
+    if( !g_opentracker_running ) goto werr;
+  }
+
+  /* EOF opcode */
+  c = OT_DUMP_EOF;
+  if (fwrite(&c, 1, 1, fp) != 1) goto werr;
+
+  /* Make sure data will not remain on the OS's output buffers. */
+  fflush(fp);
+  fsync(fileno(fp));
+  fclose(fp);
+
+  /* Use RENAME to make sure the dump file is changed atomically 
+   * only if the generate dump file is ok. */
+  if (!g_persistfile) {
+      g_persistfile = strdup("opentracker.odb");
+  }
+
+  if (rename(tmpfile, g_persistfile) < 0) {
+    unlink(tmpfile);
+    return -1;
+  }
+
+  dump_dirty = 0;
+  dump_lastsave = g_now_seconds;
+  return 0;
+
+werr:
+  LOG_ERR("%s: persist dump odb file:%s failed\n", __FUNCTION__, tmpfile);
+  fclose(fp);
+  unlink(tmpfile);
+  return -1;
+}
+
+int persist_set_mode(char *value) {
+  while( isspace(*value) ) ++value;
+  if (!strcmp(value, "null")) {
+    g_persistmode = PMODE_NULL;
+  } else if (!strcmp(value, "dump")) {
+    g_persistmode = PMODE_DUMP;
+  } else {
+    return -1;
+  }
+  return 0;
+}
+
+static void * persist_worker( void * args ) {
+  size_t i = 0;
+  (void)args;
+
+  while (1) {
+    if (g_persistmode == PMODE_DUMP) {
+      for (i = 0; i < saveparam_len; ++i) {
+        dump_saveparam_t *sp = saveparams + i;
+        if (dump_dirty >= sp->changes && g_now_seconds - dump_lastsave > sp->seconds) {
+          persist_dump_make();
+        }
+      }
+      if( !g_opentracker_running ) return NULL;
+      usleep(PERSIST_SLEEP_INTERVAL);
+    } else {
+      return NULL;
+    }
+  }
+}
+
+static pthread_t thread_id;
+void persist_init( ) {
+  if (g_persistmode != PMODE_NULL) 
+    pthread_create( &thread_id, NULL, persist_worker, NULL );
+}
+
+void persist_deinit( ) {
+  if (g_persistmode != PMODE_NULL)
+    pthread_cancel( thread_id );
+  if (saveparams) free(saveparams);
+  if (g_persistfile) free(g_persistfile);
+}
+
+const char *g_version_persist_c = "$Source: ot_persist.c Added by FengGu <flygoast@126.com>,v $: $Revision: 0.01 $\n";
diff --git a/ot_persist.h b/ot_persist.h
new file mode 100644
index 0000000..94930ce
--- /dev/null
+++ b/ot_persist.h
@@ -0,0 +1,39 @@
+/* This fill add persistence of peers and torrents in memory on the fly.
+ * Author: FengGu <flygoast@126.com>
+ *
+ * This software was written by Dirk Engling <erdgeist@erdgeist.org>
+ *    It is considered beerware. Prost. Skol. Cheers or whatever.
+ *
+ *       $id$ */
+
+#ifndef __OT_PERSIST_H_
+#define __OT_PERSIST_H_
+
+#ifdef WANT_PERSISTENCE
+
+#ifdef WANT_V6
+#error "Persist don't surport IPV6"
+#endif
+
+extern char *g_persistfile;
+
+typedef enum {
+    PMODE_NULL = 0x00,
+    PMODE_DUMP = 0x01,
+} ot_pmode;
+
+void persist_init();
+void persist_deinit();
+int persist_load_file();
+void persist_change(struct ot_workstruct *ws);
+int persist_set_mode(char *value);
+void persist_append_save_param(time_t seconds, int changes);
+
+#else
+
+#define persist_init()
+#define persist_deinit()
+
+#endif /* WANT_PERSISTENCE */
+
+#endif /* __OT_PERSIST_H_ */
diff --git a/ot_stats.c b/ot_stats.c
index 3836a8d..aeda280 100644
--- a/ot_stats.c
+++ b/ot_stats.c
@@ -560,13 +560,15 @@ static size_t stats_return_everything( char * reply ) {
 extern const char
 *g_version_opentracker_c, *g_version_accesslist_c, *g_version_clean_c, *g_version_fullscrape_c, *g_version_http_c,
 *g_version_iovec_c, *g_version_mutex_c, *g_version_stats_c, *g_version_udp_c, *g_version_vector_c,
-*g_version_scan_urlencoded_query_c, *g_version_trackerlogic_c, *g_version_livesync_c, *g_version_rijndael_c;
+*g_version_scan_urlencoded_query_c, *g_version_trackerlogic_c, *g_version_livesync_c, *g_version_rijndael_c,
+*g_version_persist_c;
 
 size_t stats_return_tracker_version( char *reply ) {
-  return sprintf( reply, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+  return sprintf( reply, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
                  g_version_opentracker_c, g_version_accesslist_c, g_version_clean_c, g_version_fullscrape_c, g_version_http_c,
                  g_version_iovec_c, g_version_mutex_c, g_version_stats_c, g_version_udp_c, g_version_vector_c,
-                 g_version_scan_urlencoded_query_c, g_version_trackerlogic_c, g_version_livesync_c, g_version_rijndael_c );
+                 g_version_scan_urlencoded_query_c, g_version_trackerlogic_c, g_version_livesync_c, g_version_rijndael_c,
+                 g_version_persist_c);
 }
 
 size_t return_stats_for_tracker( char *reply, int mode, int format ) {
diff --git a/ot_udp.c b/ot_udp.c
index 7c688d1..d282704 100644
--- a/ot_udp.c
+++ b/ot_udp.c
@@ -194,7 +194,7 @@ void udp_init( int64 sock, unsigned int worker_count ) {
   if( !g_rijndael_round_key[0] )
     udp_generate_rijndael_round_key();
 #ifdef _DEBUG
-  fprintf( stderr, " installing %d workers on udp socket %ld", worker_count, (unsigned long)sock );
+  fprintf( stderr, "installing %d workers on udp socket %ld\n", worker_count, (unsigned long)sock );
 #endif
   while( worker_count-- )
     pthread_create( &thread_id, NULL, udp_worker, (void *)sock );
diff --git a/trackerlogic.c b/trackerlogic.c
index 524246a..c56abd2 100644
--- a/trackerlogic.c
+++ b/trackerlogic.c
@@ -27,6 +27,7 @@
 #include "ot_accesslist.h"
 #include "ot_fullscrape.h"
 #include "ot_livesync.h"
+#include "ot_persist.h"
 
 /* Forward declaration */
 size_t return_peers_for_torrent( ot_torrent *torrent, size_t amount, char *reply, PROTO_FLAG proto );
@@ -171,6 +172,11 @@ size_t add_peer_to_torrent_and_return_peers( PROTO_FLAG proto, struct ot_workstr
   }
 
   memcpy( peer_dest, &ws->peer, sizeof(ot_peer) );
+
+#ifdef WANT_PERSISTENCE
+  persist_change(ws);
+#endif /* WANT_PERSISTENCE */
+
 #ifdef WANT_SYNC
   if( proto == FLAG_MCA ) {
     mutex_bucket_unlock_by_hash( *ws->hash, delta_torrentcount );
@@ -384,6 +390,10 @@ size_t remove_peer_from_torrent( PROTO_FLAG proto, struct ot_workstruct *ws ) {
     ws->reply_size = 20;
   }
 
+#ifdef WANT_PERSISTENCE
+  persist_change(ws);
+#endif /* WANT_PERSISTENCE */
+
   mutex_bucket_unlock_by_hash( *ws->hash, 0 );
   return ws->reply_size;
 }
@@ -424,6 +434,9 @@ void trackerlogic_init( ) {
   accesslist_init( );
   livesync_init( );
   stats_init( );
+#ifdef WANT_PERSISTENCE
+  persist_init( );
+#endif /* WANT_PERSISTENCE */
 }
 
 void trackerlogic_deinit( void ) {
@@ -445,6 +458,9 @@ void trackerlogic_deinit( void ) {
   }
 
   /* Deinitialise background worker threads */
+#ifdef WANT_PERSISTENCE
+  persist_deinit( );
+#endif /* WANT_PERSISTENCE */
   stats_deinit( );
   livesync_deinit( );
   accesslist_deinit( );
